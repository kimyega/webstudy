<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>

    /*
      선언 함수
      1. 함수의 이름이 있다.
      2. 함수 정의(함수를 만드는 것)와 함수 호출(함수를 사용하는 것)로 구분한다.
      3. 함수 정의 형식
        function 함수명([매개변수]){
          함수 본문
          return 반환값;
        }
      4. 함수 호출 형식
        함수명([인수]);

    */

   myFunc1();

   // 함수 정의(호이스팅 대상이므로 언제나 먼저 처리된다.)
    function myFunc1(){
      console.log('hamsuu silhangdwaem');
    }
  </script>
  <script>

    /*
      익명 함숙
      1. 함수의 이름이 없다.
      2. 호이스팅 대상이 아니다. (함수 정의를 반드시 먼저 해야 한다.)
      3. 함수 정의 형식
        1) 일반 익명 함수  
          function([매개변수]){
              함수 본문
              return 반환값;
            }
        2) 화살표 익명 함수
          ([매개변수]) =>{
            함수 본문
            return 반환값;
          }
      4. 함수 호출 방식
          1) 함수를 변수에 저장하기
            (1) 일반 익명 함수
              var 변수(함수명) = function(){

              }
              함수명();
            (2) 화살표 익명 함수
            var 함수명 = () =>{

            }
            함수명();
          2) 자기 호출  (함수 정의와 함수 호출이 동시에 진행)
            (1) 일반 익명 함수
              (function(){

              })();
            (2) 화살표 익명 함수
            (()=>{

            })();
          3) 이벤트 리스너로 등록하기 (이벤트에 따라 함수가 동작하는 방식)
            (1) 일반 익명 함수 
              문서객체.addEventListener('이벤트', function(){
              
              })
            (2) 화살표 익명 함수
              문서객체.addEventListener('이벤트', ()=>{

              })
    */

    // 1) 함수를 변수에 저장하기
    var myFunc2 = function(){
      console.log('Hello World!');
    }
    myFunc2();
    
    // 2) 자기 호출
    (function(){
      console.log('자기 호출 실행');
    })();

    // 3) 이벤트 리스너

    document.addEventListener('dblclick', function(){
      console.log('이벤트 리스너 실행');
    })

   </script>


   <script>
    /*
      인수와 매개변수
      1. 매개변수를 선언할 때는 선언 키워드(var, let, const)를 사용하지 않는다. (매개변수는 변수명만 작성한다.)
      2. 디폴트 매개변수 처리가 가능하다.
        1) 변수를 선언하고 어떤 값도 저장하지 않으면 undefined 값을 가진다.
        2) 매개변수로 인수를 전달하지 않으면 매개변수는 undefined 값을 가진다.
        3) 매개변수의 undefined 여부에 따라 매개변수의 초기화 작업을 진행할 수 있다.
        4) 매개변수에 디폴트 값을 직접 저장할 수 있다.  
      3. 전개 연산자(...)가 존재한다.
        1) 인수의 개수가 정해지지 않은 경우에 사용한다.
        2) 매개변수를 배열로 처리한다.
      4. 인수를 저장하는 arguments 객체가 있다.
        1) 매개변수를 선언하지 않아도 모든 변수는 arguments 객체에 저장된다.
        2) arguments 객체는 배열과 유사하게 동작한다.
    */

    // 인수와 매개변수
    function myFunc3(a){
      console.log(a);
    }
    myFunc3(10);
    myFunc3('Hello World');
    var a = true; 
    myFunc3(a);

    // ananymous
    (function(b){
      console.log(b);
    })(1000);

    var myFunc4 = function(c){
      console.log(c);
    }
    myFunc4(10000);
    myFunc4('Hello');

    var myFunc4 = (d)=>{
      console.log(d);
    }
    myFunc4(10010);

    // 디폴트 매개변수
    function myFunc5(a){
      if(a === undefined){
        a = 0;
      }
      console.log(a);
    }
    myFunc5();

    function myFunc6(a = 10){
      console.log(a);
    }
    myFunc6();

    function myFunc7(...a){
      for(let i = 0; i < a.length; i++){
        console.log(a[i]);
      }
    }
    myFunc7(1, 2, 3, 4, 5);

    function myFunc8(){
      for(let i = 0; i < arguments.length; i++){
        console.log(arguments[i]);
      }
    }
    myFunc8(6, 7, 8, 9, 10);

    /*
      반환(return)
      1. 반환 타입을 작성하지 않는다.
      2. return 반환값;을 통해서 값을 반환할 수 있다.
      3. return; 을 통해서 함수를 종료할 수 있다.
    
    */

    var myMax = function (a, b, c){
      if(isNaN(a) || isNaN(b) || isNaN(c)){
        return;
      }
      let max = a;
      if(max < b) max = b;  
      if (max < c) max = c;
      return max;
    }

    var myMin = function (a, b, c){
      if(isNaN(a) | isNaN(b) | isNaN(c)){
        return;
      }
      let min = a;
      if(min > b) min = b;
      if(min > c) min = c;
      return min;
    }
    function myMedium(a, b, c){
      if(isNaN(a) || isNaN(b) || isNaN(c)){
        return;
      }
      let med = a;
      if((b != myMax(a, b, c)) && (b != myMin(a, b, c))) med = b;
      if((c != myMax(a, b, c)) && (c != myMin(a, b, c))) med = c;
      return med;
    }
    function myMedium2(a, b, c){
      var arr = [a, b, c];
      arr.sort();
      document.writeln(arr);
    }
    console.log(myMedium(9, 4, 10)); 
    console.log(myMedium2(9, 4, 10)); 
   </script>

   <script>

    /*
      콜백 함수
      1. 함수에 함수를 전달할 수 있는 개념이다.
      2. 인수(함수) -> 매개변수(함수르르 저장한 변수)흐름으로 작성해야 한다.
      3. 함수를 전달 받은 함수는 매개변수를 함수 호출하듯이 처리하여 전달 받은 함수를 실행한다.
    */

    function myFunc9(a){
      a();
    }
    myFunc9(function(){
      console.log('함수 호출');
    });

    function myFunc10(a, b, callback){
      callback(a, b);
    }
    myFunc10('Hello', 'World', function(x, y){
      console.log(x, y);
    })
   </script>
   
   <script>
    /*
      재귀 호출
      1. recursive call
      2. 어떤 함수가 자신을 호출하는 것을 의미한다.
      3. 반복 동작을 구현할 때 사용한다.
     */
    /*
     * factorial 구하기 
     * 5! = 5 * 4! = 5*4*3*2*1
     */ 
    function factorial(a){
      if(a === 1){
        return 1;
      } else {
        return a * factorial(a - 1);
      }
    }
    console.log(factorial(5));

  </script>

  <script>
    /*
      타이머 함수 (내장 함수)

      1. setTimeout
        1) 특정 시간 후에 한 번만 동작한다.
        2) 동작
          var timerId = setTimeout(함수, 시간(밀리초));
        3) 동작 취소
          clearTimeout(timerId);
      2. setInterval
        1) 특정 시간 간격으로 반복해서 동작한다.
        2) 동작
          var timerId = setInterval(함수, 시간(밀리초));
        3) 동작 취소
          clearInterval(timerId);
    */
    var timerId = setTimeout(function(){
      console.log('3초 지났으');
    }, 3000);
    clearTimeout(timerId);

    var n = 1;
    var timerId = setInterval(() => {
      if(n > 10){
        clearInterval(timerId);
      } else {
        console.log(n++);
      }
    }, 1000);
    clearInterval(timerId);

    
    
    </script>

    <style>
      div[id="timer"] > {
        color: aqua;
      }
    </style>
    <div id="timer"></div>
    <script>
      // 문제 5초 타이머 동작시키기
      var n = 5;
      var timerId = setInterval(function(){
        if(n === 0){
          
          document.writeln('발사!'.fontcolor("crimson").big().fontsize(20));
          clearInterval(timerId);
        } else {
          document.writeln(n-- + '<br>');
        }
      }, 1000);
      clearInterval(timerId);
    </script>

    <div id="timer2"></div>
    <script>
      var timer2 = document.getElementById('timer2');
      function myTimer(countDown){
        setTimeout(function(){
          if(countDown === 0){
            timer2.innerHTML = '<h1>발사</h1>';
          } else { 
            timer2.innerHTML = '<h1>' + countDown + '</h1>';
            myTimer(countDown - 1);
          }
        }, 1000);
      }
      myTimer(5);

    </script>

    <script>

      // 객체 속성 동적 처리(추가, 삭제, 수정)

      var car = {};

      car.model = '모닝';
      car.maker = 'kia';

      car.model = '레이';

      delete car.maker;

      console.log(car);
    </script>

    <script>
      /*
        생성자 함수
        1. 객체를 만드는 함수이다.
        2. new 키워드를 이용해서 객체를 만들 수 있다.
        3. 관례상 첫 글자를 대문자로 작성한다.
        4. 생성자 함수 형식
        fuction 함수명(매개변수, 매개변수, ...){
          this.속성 = 매개변수;
          this.속성 = 매개변수;
          ...
        }
      */
     function Product(code, name, price){
      this.code = code;
      this.name = name;
      this.price = price;
     }

     var product = new Product('A123', '청소기', 10000);

     console.log(product['code']);
     console.log(product['name']);
     console.log(product['price']);
    </script>

    <script>
      // 객체는 for-in문으로 각 속성을 순회할 수 있다.
      var book = {
        title: '어린왕자',
        author: '생택쥐베리',
        price: 10000
      };
      for(let p in book){
        console.log(book[p]);
      }
    </script>

    <style>
      div > table {
        box-sizing: border-box;
      }
    </style>
    <div id="box"></div>
    <script>
      function tableF(name, phoneNo, email){
        this.name = name;
        this.phoneNo = phoneNo;
        this.email = email;
      }
      var table1 = new tableF('숙희', '010-1111-1111', 'sookhe@gamil.com');
      var table2 = new tableF('정희', '010-2222-2222', 'junghee@gmail.com');
      var table3 = new tableF('미희', '010-3333-3333', 'minhee@gmail.com');

      var arr1 = [table1, table2, table3];

      var str = '';
      str += '<table border="1"> <thead><tr><td>성명</td><td>연락처</td><td>이메일</td><tr></thead><tbody>';
      for(let p in arr1){
        // str += '<tr>';
        // for(let q in p){
        //   str += '<td>' + arr1[p][q] + '</td>';
        // }
        // str += '</tr>';
        str += '<tr><td>' + arr1[p].name + '</td>';
        str += '<td>' + arr1[p].phoneNo + '</td>';
        str += '<td>' + arr1[p].email + '</td></tr>';
      }
      str += '</tbody></table>';
      document.getElementById('box').innerHTML = str;

    </script>
</body>
</html>